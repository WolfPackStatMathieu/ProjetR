---
title: "Rbase vs SkimR"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: "Un tutoriel sur les différences entre summary() de Rbase et le package skimr"
---

```{r setup, include=FALSE}
##### Configuration pour learnr et gradethis #####
# install.packages("remotes") # require {remotes}
#remotes::install_github("rstudio/learnr")
#remotes::install_github("rstudio-education/gradethis")
library(learnr)
library(gradethis)
gradethis::gradethis_setup()

###### Installation du package pour le tuto, chargement et récupération du jeu de données:#####
install.packages("skimr", repos = "https://cloud.r-project.org/")
library(skimr)
install.packages("questionr", repos = "https://cloud.r-project.org/")
library(questionr)
install.packages("tidyverse", repos = "https://cloud.r-project.org/")
library(tidyverse)
data(list="hdv2003")
data(list="rp2012")
####### Option des exercices #####
tutorial_options(exercise.completion = FALSE)

knitr::opts_chunk$set(echo = FALSE)


#### Fonctions
random_praises <- c(
  "Quel talent!",
  "Trop fort!",
    "Bravo !",
  "Félicitation !",
  "Tu assures !",
   "Parfait",
  "Prodigieux !",
  "Extraordinaire !",
  "Tu es le boss !",
  "Tu es désormais membre de l'élite R !",
  "Wunderbar !",
  "Génial !",
  "Magnifique !",
  "Splendide !",
  "Perfetto !"
)


random_praiseFR <- function() {
  paste0("Correct! ", sample(random_praises, 1))
}
random_encouragements <- c(
  "Allez, tu vas y arriver !",
  "Encore un petit effort!",
   "Confiance, tes efforts vont payer !",
  "Il est dur d'échouer, mais il est pire de n'avoir jamais tenté de réussir. Courage !",
  "Le succès n'est pas final, l'échec n'est pas fatal, c'est le courage de continuer qui compte. Alors, courage !",
  "L'obstination est le chemin de la réussite. Obstine-toi !",
  "C'est en forgeant qu'on devient forgeron. Tu es sur la bonne voie !",
  " La maîtrise s'acquiert par la pratique ",
  "Essaie encore, c'est le métier qui rentre",
  "Aie confiance, tu vas réussir !",
  "Pour pouvoir contempler l'arc-en-ciel, il faut d'abord endurer la pluie. Sors ton parapluie et continue !",
  "L'échec est l'épice qui donne la saveur au succès. Continue tes efforts !"
)


random_encouragementFR <- function() {
  paste0("Correct! ", sample(random_encouragements, 1))
}

```
# Rbase vs SkimR

## Statistique descriptive avec RBase {data-progressive=TRUE}
Alors comme ça, tu veux apprendre à skimmer ? Bien, tu es au bon endroit. Dans pas longtemps, tu pourras toi aussi narguer tes camarades qui utilisent *encore* des commandes de **Rbase**. 
Bien, Mais tu le sais, un bon statisticien passe du temps à connaître son objet. Alors nous allons commencer en douceur avec un jeu de données issu de l'enquête Histoire de vie de l'Insee. Il faut bien justifier son salaire...

## Connaissez-vous bien votre jeu de données ?
Le jeu de données est préchargé. Il s'appelle **hdv2003**, et nous allons commencer par déterminer des éléments simples à son propos. Quelle taille fait-il ? Comment s'appellent les noms des colonnes ? De quoi sont-elles faites? ... Que des choses utiles pour la suite ! 

## Prendre la dimension du problème
Ton jeu de données est un *tableau* de données. Mais un tableau, c'est avant tout quelque chose de rectangulaire qui peut se décomposer en lignes et en colonnes. Eh bien! qu'allons nous faire maintenant ? ... Exact! Nous allons compter le nombre de lignes et le nombre de colonnes.
Pour cela, nous allons utiliser la fonction **dim()** sur l'objet **hdv2003**. 
Tu ne sais pas faire ? N'aie crainte, voici un petit exemple sur un autre jeu de données qu'il te suffira de reproduire sur le tien.

```{r exempledim, echo=TRUE}
dim(rp2012)
```
Ainsi, la fonction **dim()** appliquée au jeu de données *rp2012* nous indique que ce dernier contient 5170 lignes et 60 colonnes.
   
Allez, c'est à ton tour maintenant. Trouve le nombre de lignes et de colonnes du tableau de données hdv2003
```{r jeudedonnees, exercise = TRUE, exercise.eval=FALSE, exercise.cap="Ecris ton code" ,exercise.startover = TRUE}


```
```{r jeudedonnees-hint-1}
dim(...)

```

```{r jeudedonnees-solution}
dim(hdv2003)
```
<div id="jeudedonnees">
**Indice:** Tu peux trouver un indice puis la solution en cliquant sur l'ampoule!
</div>

```{r jeudedonnees-code-check}
grade_code(glue_correct = random_praiseFR())
```

```{r dim-quizz, echo=FALSE, exercise.startover = TRUE}
question("Combien de lignes et de colonnes contient hdv2003 ? ",
answer(text = "5170 lignes et 60 colonnes", message = "Ne confonds tu pas avec le jeu de données de l'exemple ?"),
answer(text = "60 lignes et 5170 colonnes", message = "Je crois que tu confonds avec le jeu de données de l'exemple, et en plus tu as inversé les lignes et les colonnes"),
answer(text = "2000 lignes et 20 colonnes", correct = TRUE, message = "Bravo, le monde de la statistique descriptive s'ouvre à toi !"),
answer(text = "20 lignes et 2000 colonnes", message = "Oups, je crois que tu as inversé les lignes et les colonnes !"),
incorrect = "Bien joué, mais essaye encore !",
allow_retry = TRUE,
random_answer_order = TRUE
         )

```





## Trouvons le nom des variables
Super ! Tu as bien trouvé la forme de ton tableau de données, aussi appelé *dataframe* par nos amis outre-Manche. Sauf, que maintenant, tu aimerais en savoir plus. Ainsi, après avoir considéré ses formes, tu voudrais bien s'avoir comment il s'appelle. Il suffit de lui demander! Tu vas pouvoir obtenir le nom de chacune des variables très facilement. 

Pour obtenir le nom des variables, utiliser la commande `names()` sur le jeu de données *hdv2003*:
```{r nomDesVariables, exercise = TRUE, exercise.eval=FALSE, exercise.startover = TRUE}
 
```
<div id="nomDesVariables-hint-2">
**Indice:** Il va falloir utiliser le jeu de données `hdv2003` à l'intérieur de la fonction  names()`.
</div>

```{r nomDesVariables-hint-1}
names(...)
```
```{r nomDesVariables-hint-2}
names(hdv....) 
```
```{r nomDesVariables-solution}
names(hdv2003)
```
##une modif après update git

## type des variables
Enfin, pour avoir le type de variables, utiliser la fonction `str()`
```{r typeDesVariables, exercise=TRUE, exercise.eval=FALSE, exercise.startover = TRUE}

```
<div id="typeDesVariables-hint-1">
**Indice:** Appliquer la même méthode que pour la fonction **names()** mais pour la fonction **str()**`.
</div>
```{r typeDesVariables-hint-1}
#Utiliser
str(...)

```


```{r typeDesVariables-solution}
str(hdv2003)
```
Comme vous le constatez, str() est une fonction bien plus complète que names().

On trouve ainsi :
- 15 variables catégorielles de type factor
- 5 variables quantitatives (3 entiers et 2 numériques)
## Le facteur n’est pas passé ?
Les facteurs (factors an anglais) sont un type de vecteur géré nativement par R et utilisés dans de nombreux domaines (modèles statistiques, représentations graphiques,…). 

Les facteurs prennent leurs valeurs dans un ensemble de modalités prédéfinies et ne peuvent en prendre d’autres. 
La liste des valeurs possibles est donnée par la fonction levels.

Par exemple, ici :


```{r exemple-facteur, exercise = TRUE, exercise.eval = TRUE, exercise.startover = TRUE}
levels(hdv2003$sexe)
```

## Exercice 2. Montre-moi tes statistiques et je te dirai qui tu es !
Maintenant que vous connaissez la structure de votre base de données, allons un peu plus loin dans sa description statistique.

### allons plus loin

A l’aide d’une commande dédiée issue de Rbase (autrement dit, sans recourir à l’utilisation d’un package annexe), produire les principales statistiques descriptives du jeu de données hdv2003

```{r qui-tu-es, exercise=TRUE, exercise.eval=FALSE}

```
```{r qui-tu-es-solution}
summary(hdv2003)
```
En effet, pour obtenir des statistiques élémentaires à partir des fonctionnalités de Rbase, on utilise la fonction summary().
La fonction summary() offre une information statistique exhaustive sur l’ensemble des variables de la table.

### trop de décimales ?
Le nombre de décimales des sorties ne vous convient pas ? Il est alors possible de spécifier le nombre de chiffres à afficher grâce au paramètre digits.
```{r decimales, exercise=TRUE, exercise.eval=FALSE}

```
```{r decimales-solution}
summary(hdv2003, digits = 3)
```


## Exercice 3 Focus sur une ou plusieurs variables d’intérêt
La fonction summary() produit un résumé statistique de toutes vos variables. Il est cependant possible de cibler une variable d’intérêt dans votre analyse. Pour cibler une variable de la sorte, il suffit de taper summary(Nom_de_la_table$Nom_de_la_variable).

Selon le même principe, produisez les principales statistiques de la variable **âge**.
```{r exo3, exercise=TRUE}

```

```{r exo3-solution}
summary(hdv2003$age)
```
### un petit quizz
```{r quizzexo3, echo=FALSE}
quiz(caption = "Un joli quiz",
  question(text = "A partir des résultats de la fonction summary(), pouvez-vous dire quelque chose sur l’allure générale de la distribution de cette variable ? (plusieurs réponses possibles)",
    answer(text = "Non, et je ne sais pas pourquoi", message = "Pense à FC"),
    answer(text = "Oui, et je ne sais pas quoi ajouter", message = "de la réflexion ?" ),
    answer(text= "Non, on ne peut rien dire sur l’allure générale de la distribution", correct = TRUE),
    answer(text = "La médiane est très proche de la moyenne (signe d’une faible dispersion)", correct = TRUE),
    allow_retry = TRUE,
    random_answer_order = TRUE,
    post_message = random_praiseFR()
    
  )
  
)
```
QCM:
A partir des résultats de la fonction summary(), pouvez-vous dire quelque chose sur l’allure générale de la distribution de cette variable ?
Non, et je ne sais pas pourquoi
Oui, et je ne sais pas quoi ajouter
Non, on ne peut rien dire sur l’allure générale de la distribution
La médiane est très proche de la moyenne (signe d’une faible dispersion)

Réponse : Certes, la médiane est très proche de la moyenne (signe d’une faible dispersion), mais on ne peut rien conclure d’autre sur l’allure générale de la distribution.

<!--Début de la partie SKIM : présentation de skim rapide avant exo 4 puis exhaustive après l’exo 4-->

# Partie Skim
L’extension SkimR permet de fournir un résumé statistique respectant le principe de moindre surprise, afin d’éviter à l’utilisateur toute (mauvaise) surprise. La fonction skim(), très similaire à la fonction summary(), fonctionne avec des data frames et affiche des résultats pour chaque colonne( Le tableau de données doit être structuré selon le format tidy, càd les variables sont en colonne, chaque variable ne correspond qu’à une seule colonne, les observations sont en lignes. L’intersection d’une ligne et d’une colonne est alors une valeur mesurée.),les statistiques présentées dépendent du typage de la variable.

## Exercice 4
Afficher les principales statistiques descriptives de votre jeu de données complet, en recourant cette fois-ci au package skimR et à sa fonction skim()
```{r exo4, exercise=TRUE, exercise.eval=FALSE}

```

```{r exo4-solution}
skim(hdv2003)
```
La fonction skim() fournit deux tableaux de paramètres distincts, en fonction du type des variables. 

On retrouve pour les variables numériques :
    • Var : le nom de la variable
    • Missing : le nombre total de valeurs manquantes
    • Complete_rate : le taux de valeurs non-manquantes
    • N : le nombre total de valeurs
    • Mean : la moyenne arithmétiques des valeurs
    • Sd : l’écat-type des valeurs
    • Min : le minimum des valeurs
    • P25 : le 1er quartile des valeurs
    • Median : la médiane des valeurs
    • P75 : le 3ème quartile des valeurs
    • Max: le maximum des valeurs
    • Hist : l’histogramme de la distribution des valeurs

On retrouve pour les variables catégorielles :

    • Var :le nom de la variable
    • missing: le nombre total de valeurs manquantes
    • complete_rate: le taux de valeurs non-manquantes
    • n_unique: le nombre de modalités de la variable observée
    • top_count: le nombre de lignes pour chaque modalités et le nombre total de données manquantes
    • ordered: si la variable est ordonnée, TRUE est affiché, FALSE sinon.

### suite
L’avantage de skim() par rapport à summary() est la pertinence des paramètres de dispersion et de position, qui sont les plus usuels pour un statisticien. Chaque type de données est présenté séparément. SkimR peut gérer les valeurs booléennes, les dates et bien d’autres types ( numérique, caractère, factor, booléen, complexes, dates, POSIXct (date avec temps, par exemple 2021-02-26 23:45 GMT), ts (des séries temporelles)et supporte les spark-bar et les spark-line (Graphiques dans les cellules du data frame, qui ne doivent donc pas être considérés comme des valeurs)
.  De plus, l’histogramme permet de rapidement regarder si la distribution de la variable choisie s’éloigne d’une distribution normale, souvent plus parlant qu’une p-value.

SkimR retourne un objet skim_df ( I.e. skim data frame). Ce dernier peut notamment être utilisé dans un pipeline tidyverse, contrairement au retour de summary() qui est une table. Si le format large ne convient pas, on peut également utiliser to_long(nom_du_data_frame, les colonnes à skimer, les fonctions de skim skim_fun=skim) qui retourne un data frame comprenant 4 colonnes : variable, type, stat et formatted.



<!--Rappel des différences entre skim et summary-->
Quelles différences observez-vous entre les 2 sorties ? Prenez quelques instants pour réfléchir puis comparez votre réflexion avec les informations suivantes : 

## Exercice 5 

```{r exo5, exercise = TRUE, exercise.eval = FALSE}

```


```{r exo5-solution}
# - Si les deux fonctions indiquent le nombre de valeurs manquantes (NA), skim indique également son complémentaire (en structure), à savoir le taux de valeurs non manquantes
# - Skim apporte une indication sur la dispersion grâce à l’écart-type
# - En sortie, les variables sont regroupées par type (pas de panique si vous ne retrouvez pas l’ordre initial des variables de votre jeu de données!)
# - Pour les variables numériques, un histogramme permet de visualiser sa distribution

```

Skimr étant compatible avec le tidyverse, d’autres syntaxes peuvent être utilisées. Par exemple, pour sélectionner des variables d’une table, on peut les lister après avoir nommé la table mère :
on peut remplacer la syntaxe table_mère$colonne_choisie1 par table_mère, colonnechoisie1. 

## Exercice 5 bis
Réalisez une analyse descriptive de la variable age de la table hdv2003

```{r exo5bis, exercise = TRUE, exercise.eval = FALSE}

```
```{r exo5bis-solution}
#Tapez les codes suivants (au choix):
skim(hdv2003$age)   #utilisation de la syntaxe de base 

skim(hdv2003,age) #utilisation de la syntaxe tidyselect


```

### suite
SkimR peut sembler rigide au premier abord. Cependant, il est possible de personnaliser les sorties et, surtout, de préciser les statistiques qui nous intéressent le plus. Nous pouvons donc remplacer, supprimer ou ajouter nos propres statistiques dans le but de simplifier encore plus son utilisation. Pour cela, il faut créer une liste de fonctions skim sfl() associée à un typage particulier de données puis les implémenter grâce à la fonction skim_with(). Pour revenir à tout moment à la configuration de base de skim_with(), il est possible de restaurer les paramètres par défaut grâce à la fonction skim_with_defaults(). 

<!--encore un rappel de la différence entre summary et skim-->

## Exercice 6 Une fonction qui a de l'allure


